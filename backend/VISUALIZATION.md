# Спецификация Системы Визуализации и Генерации Вопросов (v2.0)

Настоящий документ описывает архитектуру и требования к обновленной системе визуализации, направленной на устранение проблем масштабирования, наложения объектов и обеспечение строгой согласованности между текстом вопроса и его графическим представлением.

---

## 1. Система Координат и Позиционирования (Visualization Engine)

### 1.1. Нормализация Пространства (Canvas 10x10)
Все визуальные элементы должны быть нормализованы для отображения на холсте размером **10x10 единиц**.
- **Глобальная система координат**: `x: [0, 10]`, `y: [0, 10]`.
- **Центр координат**: Точка `(5, 5)` является логическим центром для позиционирования ключевых объектов.
- **Жесткие границы**: Ни один элемент (вершина, линия, подпись) не должен выходить за пределы `[0, 10]`.

### 1.2. Логика Размещения и Масштабирования
Алгоритм `GeometryEngine` должен выполнять следующие шаги перед отдачей JSON клиенту:

1.  **Центрирование**: Вычислить центр масс (centroid) всех сгенерированных фигур. Сместить фигуры так, чтобы их центр совпал с точкой `(5, 5)`.
2.  **Масштабирование (Scaling)**:
    - Найти `BoundingBox` (минимальные и максимальные x/y) всех объектов.
    - Вычислить текущие размеры: `width = max_x - min_x`, `height = max_y - min_y`.
    - Вычислить коэффициент масштабирования `k`:
      ```python
      target_size = 8.0  # Оставляем отступы по 1.0 с каждой стороны
      k = min(target_size / width, target_size / height)
      ```
    - Применить `k` ко всем координатам относительно центра `(5, 5)`.
3.  **Валидация Границ**: Убедиться, что после трансформации `0 <= x <= 10` и `0 <= y <= 10`.

### 1.3. Предотвращение Наложений (Collision Avoidance)
- **Ограничение количества объектов**: МАКСИМУМ **3** объекта на одной сцене (Constraint: `MAX_OBJECTS = 3`).
- **Минимальная дистанция**: Между любыми несвязанными вершинами или объектами должно быть расстояние не менее `1.0` единицы.
- **Алгоритм Repel**:
    - Если расстояние между объектами `d < 1.0`, применить вектор расталкивания (repulsion vector) от центра `(5, 5)`.
    - Логировать конфликт, если после 5 итераций расталкивания наложение сохраняется.

---

## 2. Генерация Вопросов (Adaptive Question Engine)

### 2.1. Анализ Темы и Пререквизитов
Перед генерацией вопроса система обращается к графу Neo4j:
1.  **Fetch Context**: Получить текущую тему `Topic` и все связи `[:REQUIRES]->(PrereqTopic)`.
2.  **Prereq Check**: Проверить уровень мастерства (`mastery`) по каждому пререквизиту.
    - Если `mastery(prereq) < 0.6`, генератор принудительно включает элементы из пререквизита в условие задачи для повторения.

### 2.2. Адаптивная Сложность
Уровень сложности (`difficulty` от 1 до 10) корректируется динамически:

| Фактор | Влияние на сложность |
| :--- | :--- |
| Предыдущий ответ верный | +1 уровень |
| Предыдущий ответ неверный | -1 уровень |
| Время ответа < 10 сек (Fast) | +0.5 (Бонус за уверенность) |
| Время ответа > 60 сек (Slow) | -0.5 (Штраф за неуверенность) |
| История ошибок (Last 3) | Если 2 ошибки подряд по одной подтеме -> Сброс сложности на -2 |

### 2.3. Согласованность (Consistency Check)
**Критическое требование**: Содержание вопроса должно **ВСЕГДА** соответствовать визуализации.
- **Rule**: Если в тексте вопроса упоминаются параметры (например, "сторона равна 5"), то в JSON визуализации координаты должны математически давать длину 5 (с учетом масштаба, если указан, или в относительных единицах).
- **Validation**: LLM должна возвращать флаг `visualization_matches_text: true`. Если он `false`, генерация перезапускается.

---

## 3. Система Оценки Мастерства (Mastery System)

### 3.1. Метрика Mastery Score
Показатель мастерства рассчитывается по взвешенной формуле:

```python
Mastery = (w1 * Accuracy) + (w2 * Complexity) + (w3 * SpeedFactor) + (w4 * Consistency)
```

Где:
- **Accuracy (Точность)**: % правильных ответов (окно: последние 10 вопросов).
- **Complexity (Сложность)**: Средняя сложность решенных задач (нормализованная 0..1).
- **SpeedFactor**: `1.0`, если ср. время < 30с, иначе убывает до `0.5`.
- **Consistency**: Бонус за серию правильных ответов подряд.

*Веса по умолчанию*: `w1=0.5, w2=0.3, w3=0.1, w4=0.1`.

### 3.2. Визуализация Прогресса
- **Radar Chart**: Отображение мастерства по подтемам (например, "Теория", "Вычисления", "Визуализация").
- **Timeline**: График изменения `Mastery` во времени для отслеживания динамики обучения.

---

## 4. Технические Требования

### 4.1. Визуальные Индикаторы
JSON визуализации должен поддерживать поле `indicators`:
```json
"indicators": [
  {"type": "arrow", "from": {"x": 2, "y": 2}, "to": {"x": 8, "y": 2}, "label": "a = 6"},
  {"type": "angle_arc", "center": {"x": 2, "y": 2}, "radius": 0.5, "label": "30°"}
]
```

### 4.2. Анимация
- **Fade-in**: Объекты появляются последовательно (delay 200ms) для снижения когнитивной нагрузки.
- **No Overlap**: Анимация не должна создавать временных наложений.

### 4.3. Логирование и Мониторинг
- **Logger**: `app.services.visualization.logger`
- **Event**: `VISUALIZATION_CONFLICT`
- **Payload**: `{ "topic_uid": "...", "shapes_count": 3, "conflict_type": "overlap", "coordinates": [...] }`

---

## 5. Тестирование и Валидация

### 5.1. Unit-тесты (Positioning)
Необходимо реализовать тесты для проверки `GeometryEngine`. Пример реализации на `pytest`:

```python
def test_normalization_bounds():
    shapes = [
        {"points": [{"x": 15, "y": 20}, {"x": -5, "y": 0}]}
    ]
    normalized = GeometryEngine.normalize(shapes)
    for shape in normalized:
        for p in shape["points"]:
            assert 0 <= p["x"] <= 10
            assert 0 <= p["y"] <= 10

def test_centering():
    # Создаем фигуру со смещенным центром
    # Note: Bounding box center check, not centroid of points
    shapes = [{"points": [{"x": 0, "y": 0}, {"x": 2, "y": 0}, {"x": 1, "y": 1}]}]
    normalized = GeometryEngine.normalize(shapes)
    
    xs = [p["x"] for p in normalized[0]["points"]]
    ys = [p["y"] for p in normalized[0]["points"]]
    bbox_cx = (min(xs) + max(xs)) / 2
    bbox_cy = (min(ys) + max(ys)) / 2
    
    assert abs(bbox_cx - 5.0) < 0.1
    assert abs(bbox_cy - 5.0) < 0.1

def test_max_objects():
    shapes = [{"id": i} for i in range(4)]
    with pytest.raises(ValueError, match="Too many objects"):
        GeometryEngine.validate(shapes)
```

### 5.2. Интеграционные Тесты (Consistency)
- **Scenario**: Сгенерировать 50 вопросов.
- **Check**: Парсинг текста вопроса (Regex поиск чисел) vs Вычисление параметров фигур из JSON.
- **Threshold**: Расхождение не более 5% (допуск на округление).

### 5.3. Тестовые Случаи (Test Cases)
1.  **Level 1 (Easy)**: Одна фигура (Квадрат), центр (5,5), вопрос на периметр.
2.  **Level 5 (Medium)**: Две фигуры (Треугольник и Описанная окружность), проверка на пересечения.
3.  **Level 10 (Hard)**: График функции + Касательная (Line), проверка точности точки касания.

---

## Примеры JSON (v2.0)

### Геометрическая задача (Треугольник)
```json
{
  "type": "geometric_shape",
  "canvas": {"width": 10, "height": 10},
  "coordinates": [
    {
      "type": "polygon",
      "label": "ABC",
      "color": "#4A90E2",
      "points": [
        {"x": 2, "y": 2},   // A
        {"x": 8, "y": 2},   // B
        {"x": 5, "y": 8}    // C
      ]
    }
  ],
  "indicators": [
    {"type": "dimension", "start": {"x": 2, "y": 1.5}, "end": {"x": 8, "y": 1.5}, "text": "6 см"}
  ]
}
```
