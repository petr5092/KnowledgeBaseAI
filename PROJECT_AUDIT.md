# Полный архитектурный аудит и анализ проекта KnowledgeBaseAI

## 1. Обзор архитектуры (Executive Summary)

**KnowledgeBaseAI** — это платформа для управления знаниями и адаптивного обучения, построенная на гибридной архитектуре, объединяющей графовую базу данных (Neo4j) для структурированных знаний, векторную базу (Qdrant) для семантического поиска и LLM (OpenAI) для генерации контента и рассуждений.

### Технологический стек

*   **Backend**: Python 3.12, FastAPI.
*   **Frontend**: React, TypeScript, Vite, Redux Toolkit.
*   **Базы данных**:
    *   **Neo4j**: Основное хранилище графа знаний (Темы, Навыки, Концепты).
    *   **Qdrant**: Векторный поиск (Embeddings) для семантической близости.
    *   **PostgreSQL**: (Подразумевается в коде, но используется для аутентификации/метаданных).
    *   **Redis**: Очереди задач и Pub/Sub (события изменений графа).
*   **AI**: OpenAI API (GPT-4/3.5) для генерации контента и рассуждений.
*   **Инфраструктура**: Docker Compose.

---

## 2. Детальный анализ Backend (`backend/src`)

Бэкенд организован по модульному принципу с четким разделением на API, сервисы, доменные модели и воркеры.

### 2.1. API Endpoints (`backend/app/api`)

API предоставляет RESTful интерфейс для взаимодействия с платформой.

| Модуль | Эндпоинты | Описание |
| :--- | :--- | :--- |
| **Auth** (`auth.py`) | `/register`, `/login`, `/refresh`, `/me` | Полный цикл JWT аутентификации. |
| **Proposals** (`proposals.py`) | `POST /`, `GET /`, `POST /{id}/commit`, `POST /{id}/approve` | Система управления изменениями (Git-like flow для графа). |
| **Engine** (`engine.py`) | `/viewport`, `/pathfind`, `/roadmap`, `/next-best-topic` | Основной движок обучения: получение подграфа, поиск пути, построение плана. |
| **Assessment** (`assessment.py`) | `/start`, `/next` | Модуль тестирования и оценки знаний. |
| **Assistant** (`assistant.py`) | `/chat`, `/tools` | Интерфейс для AI-ассистента. |
| **Ingestion** (`ingestion.py`) | `/generate_proposal` | Автоматическая генерация графа из текста через LLM. |
| **Admin** (`admin_graph.py`) | `/nodes`, `/edges` (CRUD) | Прямое управление графом (через механизм Proposals). |
| **Analytics** (`analytics.py`) | `/stats` | Статистика графа (плотность, количество узлов) и использования AI. |

### 2.2. Сервисный слой (`backend/app/services`)

Ядро бизнес-логики.

#### **Graph Service (`services/graph`)**
*   **`Neo4jRepo`**: Абстракция над драйвером Neo4j.
    *   `read(query)` / `write(query)`: Базовые операции.
    *   `neighbors(uid, depth)`: Извлекает окрестность узла для визуализации.
    *   `node_by_uid(uid)`: Возвращает полные данные узла.

#### **Proposal Service (`services/proposal_service.py`)**
Управляет жизненным циклом изменений.
*   **Концепция**: Любое изменение графа (создание/удаление/изменение) сначала создается как `Proposal` (черновик).
*   **`create_draft_proposal`**: Валидирует список операций (`Operation`) и создает объект заявки.
*   **`build_diff`**: Сравнивает граф "как есть" и "как будет", генерируя список различий для ревью.
*   **`commit_proposal`**: Применяет изменения в транзакции Neo4j.

#### **Reasoning & Planning (`services/reasoning`)**
*   **`roadmap_planner.py`**: Строит линейную последовательность изучения тем.
    *   `plan_route(...)`: Использует топологическую сортировку с учетом пререквизитов (`PREREQ`) и текущего прогресса пользователя.
*   **`next_best_topic.py`**: Рекомендательная система.
    *   Алгоритм: Находит темы, у которых выполнены пререквизиты, но которые еще не изучены, ранжируя их по приоритету и сложности.
*   **`gaps.py`**: Анализ пробелов. Находит неизученные пререквизиты для целевой темы.

#### **Ingestion (`services/ingestion`)**
*   **`AcademicIngestionStrategy`**: Стратегия для учебных материалов. Разбирает структуру (Предмет -> Раздел -> Тема) и генерирует соответствующие узлы графа.

### 2.3. Модели данных (Schemas)

Основные сущности, используемые в API и внутренней логике (Pydantic).

#### **Proposal & Operations** (`schemas/proposal.py`)
*   **`Proposal`**: `id`, `status` (DRAFT, APPROVED), `operations` (список действий).
*   **`Operation`**: Атомарное действие.
    *   `op_type`: `CREATE_NODE`, `CREATE_EDGE`, `UPDATE_PROPERTIES`, `DELETE`.
    *   `properties_delta`: Изменяемые поля.

#### **Knowledge Graph Entities**
*   **Nodes**:
    *   `Subject` (Предмет), `Section` (Раздел), `Topic` (Тема).
    *   `Skill` (Навык), `Concept` (Понятие), `Method` (Метод решения).
    *   `Example` (Пример задачи), `Error` (Типичная ошибка).
*   **Edges**:
    *   `CONTAINS`: Иерархия (Subject -> Section -> Topic).
    *   `PREREQ`: Зависимость (Topic A -> Topic B).
    *   `USES_SKILL`: Связь темы с навыком.
    *   `ILLUSTRATES`: Пример иллюстрирует тему.

#### **User Context** (`schemas/context.py`)
*   **`UserContext`**: Хранит язык пользователя и произвольные атрибуты для персонализации.

### 2.4. Инфраструктура и Конфигурация (`config/settings.py`)

Настройки управляются через переменные окружения (`BaseSettings`).
*   **Базы данных**: `NEO4J_URI`, `QDRANT_URL`, `PG_DSN`, `REDIS_URL`.
*   **Безопасность**: `JWT_SECRET_KEY`, `ADMIN_API_KEY`.
*   **AI**: `OPENAI_API_KEY`.

---

## 3. Детальный анализ Frontend (`frontend/src`)

SPA приложение на React + Vite.

### 3.1. Ключевые страницы (`pages/`)

*   **ExplorePage**: Основной интерфейс. Визуализирует граф с помощью библиотеки (предположительно `vis-network` или `react-force-graph`). Позволяет навигироваться по связям.
*   **EditPage**: Визуальный редактор (на базе `React Flow`). Позволяет драг-н-дропом создавать узлы и связи.
*   **ReviewDiff / ReviewAndImpact**: Интерфейс для ревьюеров. Показывает список изменений в Proposal и подграф, на который эти изменения повлияют ("Impact Analysis").
*   **RoadmapPage**: Линейный вид плана обучения (список тем в порядке изучения).

### 3.2. Управление состоянием (Redux Store)

Хранилище (`store/`) разделено на слайсы:
*   **`exploreSlice`**: Хранит текущий `viewport` (видимую часть графа), глубину отображения.
*   **`appSlice`**: Глобальные UI состояния (выбранный узел, открыт ли чат).
*   **`editSlice`**: Состояние редактора (узлы и связи в формате редактора).
*   **`roadmapSlice`**: Сгенерированный план обучения.
*   **`analyticsSlice`**: Закешированная статистика.

### 3.3. Компоненты (`components/`)

*   **AIChat**: Умный ассистент. Поддерживает режимы: "Объясни связь", "Построй маршрут".
*   **NodeDetailsSidebar**: "Карточка" узла. Показывает свойства, примеры, ошибки и навыки, связанные с темой.

---

## 4. Функционал и Инструкции по использованию

### 4.1. Создание и Наполнение Знаний (Роль: Архитектор Знаний)

Процесс наполнения базы знаний строго регламентирован через систему **Proposals**:

1.  **Автоматическая генерация**:
    *   Используйте эндпоинт `/v1/ingestion/generate_proposal`.
    *   Передайте текст учебника или оглавление.
    *   Система создаст черновик Proposal с иерархией `Subject -> Section -> Topic`.
2.  **Ручное редактирование**:
    *   Перейдите на `EditPage`.
    *   Внесите изменения (добавьте связи `PREREQ` между темами, привяжите `Skill`).
    *   Сохранение создаст новый Proposal.
3.  **Ревью и Публикация**:
    *   Перейдите на `ReviewAndImpact`.
    *   Изучите `Diff` (что добавится/удалися).
    *   Изучите `Impact` (какие соседние темы затронуты).
    *   Нажмите **Approve/Commit**. Только после этого изменения попадут в основной граф ("Master").

### 4.2. Обучение (Роль: Студент)

1.  **Исследование**:
    *   На `ExplorePage` выберите интересующий Предмет (Subject).
    *   Изучайте граф. Зеленые узлы — изучено, Серые — доступно, Красные — заблокировано (не выполнены пререквизиты).
2.  **Построение маршрута**:
    *   Выберите целевую тему.
    *   Нажмите "Build Roadmap". Система построит оптимальный путь от ваших текущих знаний до цели.
3.  **Практика**:
    *   В режиме `Assessment` система будет выдавать вопросы.
    *   Ответы обновляют ваш `UserContext` (уровень владения темами), открывая новые узлы графа.

### 4.3. Администрирование

*   Используйте `AnalyticsPage` для мониторинга "здоровья" графа (поиск "сирот" — узлов без связей, циклических зависимостей).
*   Фоновые задачи (`/v1/maintenance`) запускают пересчет индексов Qdrant и валидацию целостности графа.

---

## 5. Доменные знания и Моделирование

Для корректной работы платформы необходимо соблюдать онтологию:

*   **Topic (Тема)**: Атомарная единица знания. Должна быть маленькой (15-30 минут изучения).
*   **Skill (Навык)**: Практическое умение. Тема *использует* навык.
*   **Prerequisite**: Строгая зависимость. Нельзя понять B, не поняв A.
*   **Concept**: Абстрактное определение, которое может встречаться в разных темах.

---

## 6. Инструкция по развертыванию (Setup)

1.  **Требования**: Docker, Docker Compose.
2.  **Конфигурация**:
    *   Создайте `.env` файл на основе `.env.dev`.
    *   Укажите `OPENAI_API_KEY` и доступы к Neo4j/Qdrant (если внешние).
3.  **Запуск**:
    ```bash
    docker-compose up --build
    ```
4.  **Инициализация**:
    *   Запустите скрипт миграции схемы: `python backend/scripts/apply_schema.py`.
    *   (Опционально) Загрузите демо-данные: `python backend/scripts/load_data.py`.
5.  **Доступ**:
    *   Frontend: `http://localhost:5173`
    *   Backend API Docs: `http://localhost:8000/docs`
    *   Neo4j Browser: `http://localhost:7474`
